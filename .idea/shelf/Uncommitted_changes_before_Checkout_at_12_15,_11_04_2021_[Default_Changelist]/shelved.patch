Index: Network.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import csv\nimport numpy as np\n\nfrom scipy.spatial import distance\n\nimport Parameter as para\nfrom Network_Method import uniform_com_func, to_string, count_package_function\n\n\nclass Network:\n    def __init__(self, list_node=None, mc=None, target=None):\n        self.node = list_node  # list of node in network\n        self.set_neighbor()  # find neighbor of each node\n        self.set_level()  # set the distance in graph from each node to base\n        self.mc = mc  # mobile charger\n        self.target = target  # list of target. each item is index of sensor where target is located\n\n    def set_neighbor(self):\n        \"\"\"\n        find the neighbor of every node\n        :return:\n        \"\"\"\n        for node in self.node:\n            for other in self.node:\n                if other.id != node.id and distance.euclidean(node.location, other.location) <= node.com_ran:\n                    node.neighbor.append(other.id)\n\n    def set_level(self):\n        \"\"\"\n        find the distance in graph from every node to base\n        :return:\n        \"\"\"\n        queue = []\n        for node in self.node:\n            if distance.euclidean(node.location, para.base) < node.com_ran:\n                node.level = 1\n                queue.append(node.id)\n        while queue:\n            for neighbor_id in self.node[queue[0]].neighbor:\n                if not self.node[neighbor_id].level:\n                    self.node[neighbor_id].level = self.node[queue[0]].level + 1\n                    queue.append(neighbor_id)\n            queue.pop(0)\n\n    def communicate(self, communicate_func=uniform_com_func):\n        \"\"\"\n        communicate each time in network\n        :param communicate_func: the function used to communicating\n        :return:\n        \"\"\"\n        return communicate_func(self)\n\n    def run_per_second(self, t, optimizer=None):\n        \"\"\"\n        simulate network per second\n        :param t: current time\n        :param optimizer: the optimizer used to calculate the next location of mc\n        :return:\n        \"\"\"\n        state = self.communicate()\n        request_id = []\n        for index, node in enumerate(self.node):\n            if node.energy < node.energy_thresh:\n                node.request(mc=self.mc, t=t)\n                request_id.append(index)\n            else:\n                node.is_request = False\n        if request_id:\n            for index, node in enumerate(self.node):\n                if index not in request_id and (t - node.check_point[-1][\"time\"]) > 50:\n                    node.set_check_point(t)\n        if optimizer:\n            self.mc.run(network=self, time_stem=t, optimizer=optimizer)\n        return state\n\n    def simulate_lifetime(self, optimizer=None, file_name=\"log/energy_log.csv\"):\n        \"\"\"\n        simulate process finish when energy of any node is less than 0\n        :param optimizer:\n        :param file_name: log file\n        :return:\n        \"\"\"\n        print(\"simulate_lifetime\", file_name)\n        energy_log = open(file_name, \"w\")\n        writer = csv.DictWriter(energy_log, fieldnames=[\"time\", \"mc energy\", \"min energy\"])\n        writer.writeheader()\n        t = 0\n        while self.node[self.find_min_node()].energy >= 0 and t <= 10**7:\n            print(\"simulate_lifetime\", t)\n            t = t + 1\n            if (t - 1) % 10 == 0:\n                print(t, self.mc.current, self.node[self.find_min_node()].energy)\n            state = self.run_per_second(t, optimizer)\n            # if not (t - 1) % 50:\n            #     writer.writerow(\n            #         {\"time\": t, \"mc energy\": self.mc.energy, \"min energy\": self.node[self.find_min_node()].energy})\n            writer.writerow({\"time\": t, \"mc energy\": self.mc.energy, \"min energy\": self.node[self.find_min_node()].energy})\n\n        energy_log.close()\n        return t\n\n    def simulate_max_time(self, optimizer=None, max_time=10**6, file_name=\"log/information_log.csv\"):\n        \"\"\"\n        simulate process finish when current time is more than the max_time\n        :param optimizer:\n        :param max_time:\n        :param file_name:\n        :return:\n        \"\"\"\n        print(\"simulate_max_time\", file_name)\n        information_log = open(file_name, \"w\")\n        writer = csv.DictWriter(information_log, fieldnames=[\"time\", \"nb dead\", \"nb package\"])\n        writer.writeheader()\n        nb_dead = 0\n        nb_package = len(self.target)\n        t = 0\n        while t <= max_time and nb_package > 0:\n            print(\"simulate_max_time\", t)\n            t += 1\n            if (t-1) % 1000 == 0:\n                print(t, self.mc.current, self.node[self.find_min_node()].energy)\n            state = self.run_per_second(t, optimizer)\n            current_dead = self.count_dead_node()\n            current_package = self.count_package()\n            if current_dead != nb_dead or current_package != nb_package:\n                nb_dead = current_dead\n                nb_package = current_package\n            print(\"time {}\".format(t))\n            writer.writerow({\"time\": t, \"nb dead\": nb_dead, \"nb package\": nb_package})\n\n        information_log.close()\n        return t\n\n    def simulate(self, optimizer=None, max_time=None, file_name=\"log/energy_log.csv\"):\n        \"\"\"\n        simulate in general. if max_time is not none, simulate_max_time will be called\n        :param optimizer:\n        :param max_time:\n        :param file_name:\n        :return:\n        \"\"\"\n        if max_time:\n            t = self.simulate_max_time(optimizer=optimizer, max_time=max_time)\n        else:\n            t = self.simulate_lifetime(optimizer=optimizer)\n        return t\n\n    def print_net(self, func=to_string):\n        \"\"\"\n        print information of network\n        :param func:\n        :return:\n        \"\"\"\n        func(self)\n\n    def find_min_node(self):\n        \"\"\"\n        find id of node which has minimum energy in network\n        :return:\n        \"\"\"\n        min_energy = 10 ** 10\n        min_id = -1\n        for node in self.node:\n            if node.energy < min_energy:\n                min_energy = node.energy\n                min_id = node.id\n        return min_id\n\n    def count_dead_node(self):\n        \"\"\"\n        count the number of node which dead\n        :return:\n        \"\"\"\n        count = 0\n        for node in self.node:\n            if node.energy < 0:\n                count += 1\n        return count\n\n    def count_package(self, count_func=count_package_function):\n        \"\"\"\n        count the number of package which can go to base\n        :param count_func:\n        :return:\n        \"\"\"\n        count = count_func(self)\n        return count\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Network.py b/Network.py
--- a/Network.py	
+++ b/Network.py	
@@ -109,7 +109,7 @@
         """
         print("simulate_max_time", file_name)
         information_log = open(file_name, "w")
-        writer = csv.DictWriter(information_log, fieldnames=["time", "nb dead", "nb package"])
+        writer = csv.DictWriter(information_log, fieldnames=["time"])
         writer.writeheader()
         nb_dead = 0
         nb_package = len(self.target)
@@ -126,7 +126,7 @@
                 nb_dead = current_dead
                 nb_package = current_package
             print("time {}".format(t))
-            writer.writerow({"time": t, "nb dead": nb_dead, "nb package": nb_package})
+            writer.writerow({"time": t})
 
         information_log.close()
         return t
